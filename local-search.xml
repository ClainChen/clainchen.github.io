<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习 - 锁</title>
    <link href="/2024/12/04/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%94%81/"/>
    <url>/2024/12/04/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%94%81/</url>
    
    <content type="html"><![CDATA[<h1>乐观锁与悲观锁</h1><h2 id="悲观锁">悲观锁</h2><p>悲观锁，即以最差的情况假设每一次并发操作。简单来说，就是悲观地认为每一次并发操作都有可能受到其他线程的影响，导致数据不一致或错误。因此，悲观锁旨在一次只让一个线程进行操作，在操作完毕后再讲数据传递给下一个线程。</p><p>我们常见的<code>synchronized</code>关键字和<code>ReentrantLock</code>类就是悲观锁的一种表示形式，其能够保证代码块或者方法一次只会让一个线程执行，其余线程则需要等待锁释放。</p><h3 id="优势">优势</h3><ul><li>资源的一致性高</li><li>操作简单</li></ul><h3 id="劣势">劣势</h3><ul><li>性能开销大</li><li>死锁问题</li><li>资源浪费问题</li></ul><h2 id="乐观锁">乐观锁</h2><p>乐观锁，即认为每一次并发操作都不会出现冲突，或者概率很低。这种锁旨在让线程操作时不去上锁，而是在操作结束时对比预期值和真实值来决定操作是否成功。</p><p>我们常说的 <strong>CAS(Compare-And-Swap)</strong> 技术便是乐观锁的核心算法。<code>Atomic</code>类都是乐观锁的一种实现，其使用对数据的原子操作来确保共享资源的更新是原子的。</p><h3 id="优势-2">优势</h3><ul><li>适合高并发高吞吐场景</li><li>无锁</li><li>没有死锁问题</li></ul><h3 id="劣势-2">劣势</h3><ul><li>操作复杂</li><li>无法保证资源一致性</li><li><strong>死循环风险：</strong> 乐观锁更新失败通常都会出现自旋，自旋操作也许会因为一直不正确或者错误操作导致永远无法结束</li></ul><h2 id="乐观锁的一个简单的实现方式">乐观锁的一个简单的实现方式</h2><p>乐观锁的一个非常简单的实现方式是为数据添加一个版本号<code>version</code></p><p>假如有两个线程A和B，且他们正尝试对一个共享资源进行读和写。</p><ul><li>A读取资源值为1，获取预期<code>expectVersionA = 1</code></li><li>B读取资源值为1，获取预期<code>expectVersionB = 1</code></li><li>B尝试为资源值加1，对比<code>currentVersion = 1 == expectVersionB</code></li><li>B成功操作，将<code>version++</code></li><li>A尝试为资源值加1，对比<code>curentVersion = 2 != expectVersionA</code></li><li>由于当前<code>version</code>与预期<code>version</code>不相等，故A操作失败，执行自旋操作（重新再操作一遍）</li></ul><p>可以看到，整个操作过程中没有用到锁（或者说用了自旋锁），期间也发生了冲突的问题，但是最终却依然能够保证共享资源的一致性。</p><p>但是现实场景中肯定不止这么简单，在有大量线程并发时，这种操作也可能会变得效率低下（大量自旋操作发生）。</p><h1>synchronized(同步)</h1><p>Java的<code>synchronized</code>关键字可以用来修饰：</p><ul><li>实例方法</li><li>静态方法</li><li>代码块</li></ul><p><strong>注意：</strong><code>synchronized</code>无法用来修饰抽象方法。<code>synchronized</code>关键字是用于控制方法执行的同步，是在方法体内部实现线程同步的机制。抽象方法没有方法体，无法实现同步代码块和同步方法所需的逻辑。</p><p>早期的<code>synchronized</code>是一个<strong>重量级锁</strong>。在早期的 Java 版本中，<code>synchronized</code>关键字在底层实现上比较依赖操作系统提供的互斥锁（如通过<code>monitorenter</code>和<code>monitorexit</code>指令与对象头中的锁标志位配合）。<strong>当一个线程获取锁时，它需要向操作系统请求互斥锁资源。这种方式涉及到用户态和内核态的切换，这是一个相对复杂且耗时的过程。</strong></p><p>在Java 6之后对<code>synchronized</code>进行了大量优化：</p><ul><li>偏向锁（Biased Locking）<ul><li><strong>原理</strong>：偏向锁的核心思想是如果一段同步代码一直被一个线程访问，那么这个线程会自动获取锁，并且在之后的执行过程中，这个锁会偏向这个线程，不需要每次都进行锁的获取和释放操作。例如，在一个单线程频繁访问同步代码块的场景下，偏向锁可以大大减少获取锁的开销。当一个线程第一次访问带有<code>synchronized</code>的代码块时，JVM 会在对象头中记录这个线程的 ID，表示这个锁偏向该线程。后续这个线程再次访问时，只要检查对象头中的线程 ID 与自己一致，就可以直接进入同步代码块。</li><li><strong>性能提升</strong>：通过减少不必要的锁获取和释放操作，偏向锁能够显著提高程序在单线程访问同步代码块场景下的性能。在很多实际应用中，有相当一部分同步代码块在一段时间内是被单线程访问的，偏向锁正好可以利用这一特性。</li></ul></li><li>轻量级锁（Lightweight Locking）<ul><li><strong>原理</strong>：当出现多个线程竞争偏向锁时，偏向锁会升级为轻量级锁。轻量级锁是基于 CAS（Compare - And - Swap）操作实现的。CAS 操作是一种无锁的原子操作，它通过比较内存中的值和期望的值，如果相同则进行更新。在轻量级锁的场景下，线程会通过 CAS 操作尝试获取锁，如果获取成功，就可以进入同步代码块。如果 CAS 操作失败，说明有其他线程正在占用锁，此时线程不会立即阻塞，而是会自旋（不断尝试获取锁）一段时间。</li><li><strong>性能提升</strong>：相比于传统的重量级锁，轻量级锁避免了线程在竞争锁时立即进入阻塞状态。自旋操作在竞争不激烈的情况下，可以让线程在较短的时间内获取到锁，减少了线程上下文切换的次数，从而提高了性能。</li></ul></li><li>锁粗化（Lock Coarsening）<ul><li><strong>原理</strong>：JVM 会自动检测到一连串连续的、对同一个对象加锁和解锁的操作，并将这些操作合并为一次范围更大的加锁和解锁操作。例如，在一个循环体内频繁地对同一个对象进行<code>synchronized</code>操作，JVM 可能会将这些多次的小范围锁操作合并为一个在整个循环体外的大范围锁操作。这样可以减少获取和释放锁的次数，降低开销。</li></ul></li><li>锁消除（Lock Elimination）<ul><li><strong>原理</strong>：JVM 在编译阶段会通过逃逸分析来判断一个对象是否被多个线程访问。如果一个对象只在一个线程内被访问，即使代码中有<code>synchronized</code>操作，JVM 也会认为这个锁是不必要的，并将其消除。例如，在一个方法内部定义的局部对象，并且这个对象没有被方法返回或者传递给其他线程，那么对这个对象的<code>synchronized</code>操作就会被 JVM 消除。</li><li><strong>性能提升</strong>：通过避免不必要的锁操作，锁消除能够提高代码的性能，特别是在有大量局部对象使用<code>synchronized</code>操作的场景下。</li></ul></li></ul><div class="note note-info">            <p>从<a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">Java Guide</a>中看到了这段内容：关于偏向锁多补充一点：由于偏向锁增加了 JVM 的复杂性，同时也并没有为所有应用都带来性能提升。因此，在 JDK15 中，偏向锁被默认关闭（仍然可以使用 <code>-XX:+UseBiasedLocking</code> 启用偏向锁），在 JDK18 中，偏向锁已经被彻底废弃（无法通过命令行打开）。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java Guide](https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97)">[1]</span></a></sup></p>          </div><h1>ReentrantLock</h1><p><code>ReentrantLock</code>，顾名思义，是一个可重入的互斥锁。所谓可重入，就是指同一个线程在获取了锁之后，可以再次获取该锁而不会被阻塞，这在递归调用或嵌套同步块的场景中非常有用。例如，一个线程在进入一个同步方法后，又在该方法内部调用了另一个同样被该锁保护的同步方法，如果是不可重入锁，此时线程将会被阻塞，导致死锁的发生；而<code>ReentrantLock</code>则允许这种情况，提高了代码的灵活性和安全性。</p><p><code>ReentrantLock</code>实现了<code>Lock</code>接口，该接口定义了一系列用于获取锁、释放锁以及处理锁相关状态的方法，如<code>lock()</code>、<code>unlock()</code>、<code>tryLock()</code>等。通过这些方法，开发者可以更加精细地控制线程对共享资源的访问。</p><h2 id="ReentrantLock特性">ReentrantLock特性</h2><h3 id="可重入性">可重入性</h3><p>如前所述，<code>ReentrantLock</code>的可重入性允许一个线程多次获取同一个锁。每次获取锁时，内部的计数器会递增，而每次释放锁时，计数器会递减，当计数器为 0 时，锁才真正被释放，其他线程才有机会获取该锁。</p><h3 id="公平性与非公平性">公平性与非公平性</h3><p><code>ReentrantLock</code>中有一个内部类，名为<code>Sync</code>，其有两个子类，<code>FairSync</code>和<code>NonfairSync</code>，分别意味着公平锁和非公平锁。</p><ul><li><strong>公平模式</strong>：在公平模式下，线程获取锁的顺序遵循先来后到的原则。当锁被释放时，等待时间最长的线程将优先获取锁。这种模式可以避免线程饥饿现象，即某个线程长时间无法获取锁而一直处于等待状态。但是，公平模式的实现通常会带来一定的性能开销，因为需要维护一个等待线程的队列，并按照顺序唤醒线程。</li><li><strong>非公平模式</strong>：非公平模式下，线程获取锁时会先尝试直接获取，如果获取成功则直接进入临界区，而不会考虑是否有其他线程已经在等待。如果直接获取失败，才会像公平模式一样进入等待队列。这种模式的优点是减少了线程上下文切换和唤醒等待线程的开销，在高并发场景下可能会有更好的性能表现，但可能会导致某些线程长时间无法获取锁。</li></ul><p>默认情况下<code>ReentrantLock</code>是非公平锁，但也可以在创建<code>ReentrantLock</code>实例时通过构造函数参数指定公平模式，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//创建一个公平锁。</span><br></code></pre></td></tr></table></figure><h3 id="可中断锁与不可中断锁">可中断锁与不可中断锁</h3><p>看名字也可以明显看出来，可中断锁就是在获取锁的过程中可以被中断，而不可中断所就是一旦申请了锁，便必须等到获取了锁之后才能做别的事情。</p><p><code>ReentrantLock</code>支持锁中断操作。通过<code>lockInterruptibly()</code>方法获取锁时，如果线程在等待锁的过程中被中断，会抛出<code>InterruptedException</code>异常，从而允许线程响应中断信号并进行相应的处理。这在一些需要灵活控制线程等待时间或响应外部中断事件的场景中非常有用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试获取锁，如果被中断则抛出异常</span><br>        lock.lockInterruptibly();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 临界区代码</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// 处理中断异常</span><br>        System.out.println(<span class="hljs-string">&quot;线程被中断&quot;</span>);<br>    &#125;<br>&#125;);<br>thread.start();<br><span class="hljs-comment">// 中断线程</span><br>thread.interrupt();<br></code></pre></td></tr></table></figure><h2 id="ReentrantLock-与-synchronized-的对比">ReentrantLock 与 synchronized 的对比</h2><ul><li><p><code>ReentrantLock</code>比<code>synchronized</code>更加灵活，提供了诸如公平性选择、锁中断、条件变量等高级功能，而<code>synchronized</code>相对简单，仅提供基本的互斥和可重入功能。</p></li><li><p><code>ReentrantLock</code>可以通过<code>tryLock()</code>方法尝试获取锁，立即返回获取锁是否成功的结果，而<code>synchronized</code>在获取锁失败时会一直阻塞线程。</p></li><li><p>在低并发场景下，<code>synchronized</code>的性能与<code>ReentrantLock</code>（非公平模式）相近，因为<code>ReentrantLock</code>的非公平模式获取锁时也有一定的优化。</p></li><li><p>在高并发场景下，如果对性能要求极高且能合理利用<code>ReentrantLock</code>的特性（如非公平模式减少线程上下文切换），<code>ReentrantLock</code>可能会有更好的性能表现；但如果使用公平模式且频繁地进行锁获取和释放操作，<code>ReentrantLock</code>可能会因为维护等待队列等操作而导致性能下降，而<code>synchronized</code>的性能相对稳定。</p></li><li><p><code>synchronized</code>是 Java 语言的关键字，使用起来较为简洁，无需显式地创建锁对象和进行锁的释放操作（由虚拟机自动处理）。</p></li><li><p><code>ReentrantLock</code>需要显式地创建锁对象，并且在<code>finally</code>块中手动释放锁，以确保锁的正确释放，否则可能会导致死锁或资源泄漏等问题，这增加了代码的编写和维护成本。</p></li></ul><h1>扩展一下思维</h1><p>我们讨论了这么久锁机制，似乎目前每一个锁都只允许一个线程持有。当然，这也合理，毕竟目前我们讨论的情况都是对共享资源进行大量混合的并发操作的情况。</p><p>但是，实际上我们能够对共享资源能做的无非就是读和写两个行为，而在现实生活中，需要大规模读的情况往往远大于大规模写。而这显然是两种操作。</p><p>那么现在就可以这么想，为什么不为这两种行为分别分配一把锁呢?</p><p>这就是<strong>读写锁</strong>的由来。</p><h2 id="读写锁">读写锁</h2><p>Java中实现了读写锁的有<code>ReentrantReadWriteLock</code>，<code>StampedLock</code>。实际上就是为一个共享资源分配了两把锁，读锁和写锁。其中，读锁是<strong>共享锁</strong>，允许多个线程同时拥有。而写锁是<strong>独占锁</strong>，只能有一个线程拥有。</p><p>可以想象一下我们可以用这种锁来干什么：</p><ul><li>大量的读操作中有少许写操作：写操作的突然乱入也许会导致读的结果出现问题，但是我们可以将写锁与读锁互斥，并且让写锁的出现阻塞后续的读锁。也就是说，执行写操作的线程需要等到读操作的线程执行完毕，而同时也会阻塞后续所有线程。写锁被释放后，后续的读操作依然能够正常执行。</li><li>大量的写操作：这时候的锁的综合表现会像是重量级锁。</li></ul><p>想到这些，你也就差不多完成了对<code>ReentrantReadWriteLock</code>的理解。唯一需要加一句的是，已经获取了写锁的线程依然可以获取读锁，但是已经获取了读锁的线程却不允许获取写锁。想想为什么？</p><p>综合来说，读写锁机制会对性能带来一些提升，毕竟现在并不会限制读操作的并发访问。</p><p>然而，Java提出的<code>StampedLock</code>中引入了<strong>乐观读</strong>，旨在允许多个线程获取读锁的同时，也允许一个写线程获取写锁。这提高了并发性能，也是它比<code>ReentrantReadWriteLock</code>性能更好的原因。</p><h1>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-02.html#synchronized-%E5%85%B3%E9%94%AE%E5%AD%97">Java Guide</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁机制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习 - 进程，线程，协程</title>
    <link href="/2024/12/04/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B/"/>
    <url>/2024/12/04/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E8%BF%9B%E7%A8%8B%EF%BC%8C%E7%BA%BF%E7%A8%8B%EF%BC%8C%E5%8D%8F%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1>进程(Process)</h1><p>直观来看，在打开你的任务管理器时，出现的窗口上面就会有“进程”二字。</p><p><img src="/images/%E8%BF%9B%E7%A8%8B.png" alt="进程"></p><p>由此可以看出很多东西：</p><ul><li>进程间相互独立（关闭一个进程时，其他进程没有受到影响）<ul><li>每个进程都分配了各自的内存空间（内存隔离），来避免干扰。</li><li>一个进程无法直接访问，修改或调用另一个进程的内容。</li><li>分布式系统中，如果两端之间进行了某种通信连接，那么在某一端崩溃时需要进行错误处理来避免连带另一端发生错误。</li></ul></li></ul><p>总的来说，进程就是一个程序的生命周期。</p><h2 id="进程间如何相互通信？">进程间如何相互通信？</h2><p>即便是在同一台机器中，进程间也无法直接访问到对方的内存空间，而是需要发出请求并且获得回复。现在有很多种通信方式，举一个简单的例子就是使用TCP/IP连接。可以尝试自己写一个服务器和一个客户端，然后分别运行他们，让他们之间互相通信。这也就是一种进程间通信的方法。</p><p>现实场景中，也许更多地会用到<strong>管道（Pipe）、消息队列（Message Queue）、共享内存（Shared Memory）和信号量（Semaphore）等</strong>进程间通信的方式。</p><p>以管道为例，管道是一种半双工的通信方式，它可以在具有亲缘关系（如父子进程）的进程之间传递数据。一个进程向管道写入数据，另一个进程从管道读取数据，这个过程就像是两个房间之间通过一个管道来传递物品，而不是直接进入对方的房间（内存空间）拿东西。</p><p>共享内存机制虽然允许不同进程访问同一块物理内存区域，但进程并不能随意访问，需要通过操作系统提供的接口进行申请和管理。例如，在使用共享内存时，进程需要先请求操作系统分配共享内存段，然后通过映射等操作才能访问，并且在访问过程中还要考虑同步和互斥问题，以防止数据不一致。</p><h1>线程(Thread)</h1><p>假想一下，如果一个进程中只能从头到尾运行一个任务，而无法执行别的动作。也许可以想到，对于同一个系统，可以多创建一些进程，并让他们之间相互协作。但是，进程的创建往往伴随着新的内存空间的划分，进程之间的通信往往也是非常耗时，在面对一些需要频繁进行信息交换和修改，或有大量同时运行的系统时似乎会非常难用。因此，我们可以在同一个进程中使用多线程来解决这些问题。</p><p>然而，对于计算机来说，单核CPU每一次只能处理一个任务，因此我们看到的（单核CPU）并行任务实际上是极快的CPU处理速度和任务切换速度带来的假象。</p><p>既然多线程可以解决这些问题，那么可以看出，线程具备以下特点</p><ul><li>一个进程中可以有多个线程</li><li>线程可以直接访问同一个内存空间（<strong>共享堆和方法区资源</strong>）</li></ul><p>此外，线程当然也会有属于自己的东西：</p><ul><li><strong>程序计数器：</strong> 程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时就是通过改变程序计数器的值来选取下一条需要执行的字节码指</li><li><strong>虚拟机栈</strong> 虚拟机栈用于存储线程执行方法时的栈帧。栈帧是一个内存区域，它包含了局部变量表、操作数栈、动态连接、方法出口等信息。当一个方法被调用时，就会创建一个对应的栈帧并压入虚拟机栈；当方法执行完成时，栈帧会出栈。</li><li><strong>本地方法栈：</strong> 本地方法栈与虚拟机栈非常相似，它主要用于为本地（Native）方法服务。本地方法是指用非 Java 语言（如 C 或 C++）编写的，通过 Java 本地接口（JNI）可以被 Java 程序调用的方法。本地方法栈为这些本地方法的执行提供了类似于虚拟机栈的支持，存储本地方法调用的相关信息，如本地方法的参数、局部变量等。</li></ul><p>综上，<strong>线程是一个比进程更加轻量级的执行单位</strong>。</p><h2 id="线程的生命周期">线程的生命周期</h2><ul><li><p>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</p></li><li><p>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</p></li><li><p>BLOCKED：阻塞状态，需要等待锁释放。</p></li><li><p>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</p></li><li><p>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</p></li><li><p>TERMINATED：终止状态，表示该线程已经运行完毕。</p></li></ul><p><img src="/images/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程生命周期"></p><ul><li><p>任何的<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Waiting</mtext></mrow><annotation encoding="application/x-tex">\texttt{Waiting}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">Waiting</span></span></span></span></span>状态都可以在被其他线程的<code>notify</code>方法通知后进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Runnable</mtext></mrow><annotation encoding="application/x-tex">\texttt{Runnable}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord text"><span class="mord texttt">Runnable</span></span></span></span></span>状态。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Waiting</mtext></mrow><annotation encoding="application/x-tex">\texttt{Waiting}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">Waiting</span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Time_Waiting</mtext></mrow><annotation encoding="application/x-tex">\texttt{Time\_Waiting}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">Time_Waiting</span></span></span></span></span>状态唯一的不同就是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Time_Waiting</mtext></mrow><annotation encoding="application/x-tex">\texttt{Time\_Waiting}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.2222em;"></span><span class="mord text"><span class="mord texttt">Time_Waiting</span></span></span></span></span>多了一个时限，在Java中声明<code>sleep(long millis)</code>或<code>wait(long millis)</code>时会进入该状态，并且在超时时进入<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Runnable</mtext></mrow><annotation encoding="application/x-tex">\texttt{Runnable}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord text"><span class="mord texttt">Runnable</span></span></span></span></span>状态。</p></li><li><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">Blocked</mtext></mrow><annotation encoding="application/x-tex">\texttt{Blocked}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6111em;"></span><span class="mord text"><span class="mord texttt">Blocked</span></span></span></span></span>状态是指在线程进入到了被锁定的方法块中时，由于没有持有对应的锁导致的阻塞状态。</p></li></ul><p>综上可见，线程的运行经常会伴随着大量的状态切换。在同一个CPU在某一时刻只能运行一个线程的情况下，CPU也需要灵活地切换当前的状态来知道自己在执行哪一个线程的什么内容。但这里会出现一个问题：<strong>CPU如何知道这个线程任务在上一次暂停时运行到哪里了？</strong></p><h2 id="上下文切换">上下文切换</h2><p>在单核 CPU 中，多线程或多进程表现出的并行效果是通过时间片轮转（分时复用）机制实现的。操作系统会为每个线程或进程分配一个时间片，例如每个时间片为 10 - 20 毫秒。</p><p>当一个线程的时间片用完后，CPU 会暂停该线程的执行，保存其上下文（包括程序计数器、寄存器等状态），然后切换到下一个线程执行。由于 CPU 切换任务的速度非常快，在人的感知或者宏观层面上，就好像这些线程或进程是在同时运行。</p><p>因此，可以想一下有哪些情况会导致一个线程停止：</p><ul><li>线程调用了<code>wait()</code>或<code>sleep()</code>方法</li><li>线程的时间片用完了</li><li>线程被阻塞</li><li>线程崩溃中止</li></ul><p>前三个会需要程序存储线程当前的运行状态，造成上下文切换。而最后一个不需要。</p><h2 id="多线程问题">多线程问题</h2><p>多线程通常是并发任务，在访问和修改公共数据时也许会因为CPU调度问题出现无法预料的同步问题，这便是造成<strong>线程不安全</strong>问题的主要原因。因此，我们经常会讨论到线程安全问题，并且提出各种解决方案。</p><p>先说一下基本概念：</p><ul><li><strong>线程安全：</strong> 一个数据，不论有多少线程同时对其进行访问和修改，都能够保证这个数据的正确性和一致性。</li><li><strong>线程不安全：</strong> 一个数据，在多线程环境下，多个线程同时对其进行访问和修改时，可能导致了数据错误，丢失和不符合预期的结果。</li></ul><p>一个线程不安全的简单例子就是：对于一个数据a = 1，有两个线程，线程A要读取这个数据，另一个线程B要修改这个数据为2。假设程序中我是先运行的线程A，后运行的线程B。那么我的预期就应该是A中会获取到a = 1，B会将a修改。 但是由于出现了某些问题，线程A在准备读取数据前，线程B先完成了修改，那么线程A便获取到了a = 2。这不符合预期，也就造成了现成不安全问题。</p><p><strong>如何解决这个问题？实际上可以很轻松地想到，这类操作一次只让一个线程执行不就好了吗？</strong></p><p>这个解法，基本上就是我们最常见的<code>synchronized</code>或者是锁了。但是现实应用当中，这个解法也会带来一些问题，比如占用资源，运行效率低，死锁问题等等。因此，我们也需要想出一些别的解决方法来处理这类问题。</p><h2 id="线程池">线程池</h2><p>每一个线程的创建的销毁都伴随着一定的资源消耗，对于有大量并发的场景来说，频繁地创建和销毁线程会对系统带来极大的负担，一个个独立的线程也难以管理。因此，可以考虑使用线程池来解决这个问题。</p><h3 id="线程池的好处">线程池的好处</h3><ul><li>方便管理</li><li>节省资源</li><li>提高响应速度</li></ul><p>实际上，基本所有的好处要么就是因为线程池本身可以被理解为一个管理多个线程的类，符合面向对象的编程思想；要么就是省去了大量且频繁地创建和销毁流程。</p><h3 id="线程池的创建">线程池的创建</h3><p>Java中常见的创建线程池的方法为：</p><ul><li>ThreadPoolExecutor()</li><li>Executor框架的Executors工具</li><li>自定义线程池</li></ul><p>前两个比较常用，想要折磨一下自己或者想要充分了解线程池的一些内部细节和可能面对的问题则可以用考虑自己从头自定义线程池。</p><p>不过要注意，Executor框架中一些常用的Executors工具并不会保证程序不会出现OOM（Out-Of-Memory 内存耗尽）问题，因为它们虽然维持了一个固定量的核心线程池，但是在超过了这个核心线程池上限之后，也并不是说一定就不会再创建新线程，而是会做一些别的事情。这需要从线程池创建的流程中讲起。</p><h3 id="线程池创建流程和潜在问题">线程池创建流程和潜在问题</h3><p>以下为<code>ThreadPoolExecutor</code>的构造函数和相关参数<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java 线程池详解](https://javaguide.cn/java/concurrent/java-thread-pool-summary.html)">[1]</span></a></sup></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,//线程池的核心线程数量</span><br><span class="hljs-params">                          <span class="hljs-type">int</span> maximumPoolSize,//线程池的最大线程数</span><br><span class="hljs-params">                          <span class="hljs-type">long</span> keepAliveTime,//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br><span class="hljs-params">                          TimeUnit unit,//时间单位</span><br><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue,//任务队列，用来储存等待执行任务的队列</span><br><span class="hljs-params">                          ThreadFactory threadFactory,//线程工厂，用来创建线程，一般默认即可</span><br><span class="hljs-params">                          RejectedExecutionHandler handler//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br><span class="hljs-params">                          )</span> &#123;...&#125;<br></code></pre></td></tr></table></figure><p>线程池包含了以下关键参数：</p><ul><li>核心线程数</li><li>等待队列最大长度</li><li>最大线程数</li><li>拒绝策略</li></ul><p><strong>线程创建流程：</strong></p><p><img src="/images/%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%B5%81%E7%A8%8B.png" alt="线程创建流程"></p><p>在某一个核心线程执行完毕进入空闲状态时，会检查等待队列中是否有任务，如果有，则为这个任务分配一个线程并执行。</p><p>当一个非核心线程执行完毕后，会空闲一段<code>keepAliveTime</code>时间。如果在这段时间中一直没有新的任务请求非核心线程，则会被销毁。</p><h3 id="拒绝策略">拒绝策略</h3><ol><li><p><code>ThreadPoolExecutor.AbortPolicy</code>：抛出 <code>RejectedExecutionException</code>来拒绝新任务的处理。</p></li><li><p><code>ThreadPoolExecutor.CallerRunsPolicy</code>： 直接创建一个线程并执行新任务。也就是直接在调用<code>execute</code>方法的线程中运行(<code>run</code>)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。</p></li><li><p><code>ThreadPoolExecutor.DiscardPolicy</code>：不管了，摆了，直接丢掉</p></li><li><p><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：也是摆了，但是是丢掉最早没有执行的任务请求</p></li></ol><p>可以看出，1,3,4 都会维持一个最大线程量，而2则不会维持这个最大线程，所以也许会为程序带来一些延迟或者无法预料的问题。</p><h1>协程(Coroutine)</h1><p>Coroutine这个词挺有意思，routine可以是一个程序，co一般代表“合作”或者“多”的意思，两者加起来就成了协程。</p><p>协程（Coroutine）是一种比线程更加轻量级的用户态执行单元。它可以在一个线程内实现类似多任务的调度，允许在函数执行过程中暂停，然后在需要的时候恢复执行。</p><p><strong>跟线程比起来，线程的切换会涉及到用户态和内核态的切换，开销相对较大。协程则是在用户态中调度，有着极低的切换成本。</strong></p><p>协程提供了一种类似于顺序编程的并发模型，使得开发者可以用同步的思维方式来编写异步代码。通过使用特定的关键字（如 Python 中的<code>async/await</code>），开发者可以很方便地在函数执行过程中暂停协程，等待某个异步操作完成后再继续执行。不难发现，由于协程是在一个线程下工作，不存在多线程同时访问资源的问题，也就不会出现同步问题（因为是线性的，顺序性的执行）。</p><p><strong>既然协程对比线程有这么多的关键优势，为什么没有大量使用协程？</strong></p><ul><li><p>协程在同一个线程下运行，在多核CPU环境的今天，无法充分发挥多核的优势。</p></li><li><p>现有的系统大多数都是在多进程和多线程架构构建的，将整个系统转化为协程也许会需要将整个系统重写，成本高昂。</p></li><li><p>不是所有的编程语言都原生支持协程。虽然一些现代语言（如 Python、Go 等）对协程有很好的支持，但还有许多其他语言可能没有内置的协程机制，或者支持得不够完善。在这些语言中使用协程可能需要引入第三方库，而这些库的质量、性能和兼容性可能参差不齐。</p></li><li><p>即使在支持协程的语言中，一些现有的软件框架和库可能没有针对协程进行优化。</p></li><li><p>协程的调试相对复杂，因为其执行流程是非线性的，可能会在多个地方暂停和恢复。目前，许多调试工具是基于传统的顺序编程或者多线程编程模型设计的，对于协程的调试支持有限。</p></li></ul><p>总的来说，似乎就是生态不够完善。</p><h1>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">Java 线程池详解</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进程</tag>
      
      <tag>线程</tag>
      
      <tag>协程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习 - 集合类</title>
    <link href="/2024/12/03/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%9B%86%E5%90%88%E7%B1%BB/"/>
    <url>/2024/12/03/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%9B%86%E5%90%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>想到有关Java集合类有关的内容，就是几点：</p><ul><li>列表(ArrayList)</li><li>链表(LinkedList)</li><li>集合(Set, HashSet)</li><li>键值对(HashMap, HashTable)</li><li>线程安全</li></ul><h1>ArrayList相关</h1><p>一般来说，<strong>ArrayList</strong>要不就是跟<strong>LinkedList</strong>进行对比，要不就是询问有关<strong>线程安全</strong>相关的内容。</p><h2 id="ArrayList-VS-Vector-VS-Array-VS-LinkedList">ArrayList VS. Vector VS. Array VS. LinkedList</h2><table><thead><tr><th style="text-align:center">ArrayList</th><th style="text-align:center">LinkedList</th><th style="text-align:center">Vector</th><th style="text-align:center">Array</th></tr></thead><tbody><tr><td style="text-align:center">底层维护的是一个数组</td><td style="text-align:center">底层是一个双向链表</td><td style="text-align:center">底层维护的是一个数组</td><td style="text-align:center">本身就是一个数组</td></tr><tr><td style="text-align:center">内存是连续的</td><td style="text-align:center">内存不是连续的</td><td style="text-align:center">内存是连续的</td><td style="text-align:center">内存是连续的</td></tr><tr><td style="text-align:center">支持随机访问</td><td style="text-align:center">不支持随机访问</td><td style="text-align:center">支持随机访问</td><td style="text-align:center">支持随机访问</td></tr><tr><td style="text-align:center">线程不安全</td><td style="text-align:center">线程不安全</td><td style="text-align:center">线程安全</td><td style="text-align:center">线程不安全</td></tr></tbody></table><h2 id="ArrayList扩容">ArrayList扩容</h2><p>关于ArrayList的扩容，可以将其分阶段来讲</p><p>创建新ArrayList对象：</p><ul><li>指定了大小：ArrayList大小即为指定大小</li><li>没有指定大小：ArrayList容量初始化为0</li></ul><p>添加元素：</p><ul><li>大小不为0：判断添加元素后ArrayList长度是否超过了capacity。如果超过了：<ul><li>扩容后没有超过最大指定容量(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">MIN_ARRAY_SIZE</mtext></mrow><annotation encoding="application/x-tex">\texttt{MIN\_ARRAY\_SIZE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7063em;vertical-align:-0.0951em;"></span><span class="mord text"><span class="mord texttt">MIN_ARRAY_SIZE</span></span></span></span></span>)：<code>capacity = capacity + (capacity &gt;&gt; 1)</code>，基本上就是为原上限的1.5倍</li><li>扩容后超过了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mtext mathvariant="monospace">MIN_ARRAY_SIZE</mtext></mrow><annotation encoding="application/x-tex">\texttt{MIN\_ARRAY\_SIZE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7063em;vertical-align:-0.0951em;"></span><span class="mord text"><span class="mord texttt">MIN_ARRAY_SIZE</span></span></span></span></span>：<ul><li>超过了最大容量：<code>capacity = INTEGER.MAX_VALUE</code></li><li>没有超过最大容量：<code>capacity = MIN_ARRAY_SIZE</code></li></ul></li></ul></li><li>扩容之后，新建一个容量为新<code>capacity</code>的数组，将旧数组内容使用<code>copyof()</code>复制到新数组中，将引用指向新数组的内存地址，释放旧数组。</li></ul><h2 id="CopyOnWriteArrayList">CopyOnWriteArrayList</h2><p><strong>CopyOnWriteArrayList</strong>是一个线程安全的ArrayList，在现实中的运用场景，通常会假设读情况远远大于写情况。</p><p>在该数据结构中引入了一个“写时复制”的理念，其核心非常简单。由于假设了读频率远大于写，所以在出现写的情况时，会生成一个原数组的拷贝，然后写操作只会在这个拷贝上进行修改。在修改结束之后，再将结果覆盖到原数组上。</p><p><strong>除此以外，跟正常ArrayList的差别不大</strong>，<strong>为数不多的差别体现在CopyOnWriteArrayList中没有实现像ArrayList中那样的扩容机制。</strong></p><h1>Map相关</h1><p>Map的核心就是键值对，然后设计了一系列的针对解决高性能键值对操作问题的数据结构。</p><h2 id="HashMap-VS-HashTable">HashMap VS. HashTable</h2><table><thead><tr><th style="text-align:center">HashMap</th><th style="text-align:center">HashTable</th></tr></thead><tbody><tr><td style="text-align:center">非线程安全</td><td style="text-align:center">线程安全</td></tr><tr><td style="text-align:center">常用类</td><td style="text-align:center">古早版本的产物，少用</td></tr><tr><td style="text-align:center">接受null值</td><td style="text-align:center">不接受null值</td></tr><tr><td style="text-align:center">扩容机制: 2n</td><td style="text-align:center">扩容机制: 2n+1</td></tr><tr><td style="text-align:center">对哈希值进行了高位和低位<br />的混合扰动处理以减少冲突</td><td style="text-align:center">直接使用hashcode()</td></tr><tr><td style="text-align:center">桶大小小时：值为链表<br />桶大小大时：只为红黑树</td><td style="text-align:center">没有动态策略</td></tr></tbody></table><p><strong>扩容机制:</strong></p><p><strong>HashTable:</strong></p><ul><li>没有指定初始值：11</li><li>扩容时： 2n +1</li></ul><p><strong>HashMap:</strong></p><ul><li>没有指定初始值：16</li><li>指定了初始值：取决于初始值扩容到2的幂次方大小</li><li>扩容时：2n</li></ul><h2 id="HashCode相关">HashCode相关</h2><h3 id="经典问题：重写equals-时为什么必须重写hashCode-方法">经典问题：重写equals()时为什么必须重写hashCode()方法?</h3><p>在将类实例添加到Hash相关数据结构中时，有如下步骤：</p><ol><li>计算该实例对应的hashCode()，同时计算其他已添加到数据结构中对象的hashCode</li><li>如果没有相同hashCode，程序会认为没有相同对象被添加进结构中，否则调用equals方法来判断两个对象是否相同</li><li>根据结果，判断是否成功添加了对象</li></ol><p>由以上可以看出来，在某些情况下，equals和hashCode都被用来检测两个对象是否相等，如果没有重写hashCode方法，也许会发生以下问题：</p><ul><li>两个不同的对象由极大可能性拥有相同的hashCode，这违背了java的equals与hashcode的契约（即对象A与对象Bequals  -&gt; 对象A的hashcode与对象B的hashcode相同）</li><li>添加对象到结构中时，equals为true的两个对象也许hashcode不相同，这导致两个本应放在相近或者同一个桶中的对象被分在了不同的桶中</li><li>在结构中查找对象时，无法精确定位到目标对象，导致潜在的错误的查询失败问题</li></ul><h2 id="LinkedHashMap">LinkedHashMap</h2><p>其本质就是为每一个键值添加了一个双向链表节点的特性，让他们多了一个next指针和一个prev指针。</p><p>由于依然保留了HashMap的特性，LinkedHashMap在桶大小到了一定阈值时便将内部结构变为红黑树。因此，可以延伸出一个问题：这里的红黑树节点与HashMap的红黑树节点是一样的吗？</p><p><strong>答案是一样的</strong>，HashMap中的TreeNode继承了有双向链表特性的Entry。这让它们有着Entry的特性的同时，也拥有TreeNode的特性。只是在HashMap中并不会用到Entry的特性。Java的设计者应该是为了统一节点风格而这么做的。但是这样做，似乎会让TreeNode多了两个没有用的引用指针，导致资源浪费。关于这一点，听听Java设计者怎么说的：</p><div class="note note-info">            <p>Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins.  Inusages with well-distributed user hashCodes, tree bins arerarely used.  Ideally, under random hashCodes, the frequency ofnodes in bins follows a Poisson distribution</p>          </div><p>大意就是HashMap中的键值被转化为红黑树的可能性比较低。就算转为红黑树变为树节点，也可能会因为移除或者扩容将 <code>TreeNode</code> 变为 <code>Node</code>，所以 <code>TreeNode</code> 的使用概率不算很大，对于这一点资源空间的浪费是可以接受的。<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[LinkedHashMap 源码分析](https://javaguide.cn/java/collection/linkedhashmap-source-code.html)">[1]</span></a></sup></p><h2 id="ConcurrentHashMap">ConcurrentHashMap</h2><p>顾名思义，是一个线程安全的HashMap。这个类被分为两个时期进行讨论</p><h3 id="Java-8-以前">Java 8 以前</h3><p>采用了Segment + HashMap的方式，将HashMap数据分为多个Segment,每一个Segment中都维护着一个类似于HashMap的结构。每一个Segment中都分配了一把锁，以保证在对某一个Segment中的内容进行操作时，不会让其他Segment中的内容的读写造成影响。</p><p>这里的Segment继承了ReentrantLock，所以每一个Segment本身也就是一个可重入锁。在1.8以前，ConcurrentHashMap维护的是一个Segment数组，其大小在初始化之后便无法改变，也就是说，假设初始化大小为n，则意味着最高可支持n个线程并行操作。然而，默认n = 16。</p><h3 id="Java-8之后">Java 8之后</h3><p>摒弃了Segment，采取了Node + CAS / Synchronized 来实现线程安全。当然，这里的Node取决于键值形式，也许是双向链表Node，也也许是TreeNode。</p><p>新的ConcurrentHashMap大量使用了CAS机制来进行读写操作，但是在某些情况下依然会使用Synchronized来保证线程安全。比如说，当一个桶的大小（冲突量）超过阈值，需要将键值结构转为红黑树时，ConcurrentHashMap会使用Synchronized将该key中的内容锁住，以保证数据完整性和安全性。</p><h1>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://javaguide.cn/java/collection/linkedhashmap-source-code.html">LinkedHashMap 源码分析</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>集合类</tag>
      
      <tag>ArrayList</tag>
      
      <tag>LinkedList</tag>
      
      <tag>Queue</tag>
      
      <tag>HashMap</tag>
      
      <tag>HashTable</tag>
      
      <tag>ConcurrentHashMap</tag>
      
      <tag>Vector</tag>
      
      <tag>Array</tag>
      
      <tag>HashSet</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习 - 基本数据类型</title>
    <link href="/2024/12/03/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2024/12/03/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1>基本数据类型</h1><p>Java中有8种数据类型</p><table><thead><tr><th style="text-align:center">名称</th><th>包装类</th><th style="text-align:center">位数</th><th style="text-align:center">占用字节</th><th style="text-align:center">默认值</th><th style="text-align:center">是否有默认缓存？</th><th style="text-align:center">取值范围</th></tr></thead><tbody><tr><td style="text-align:center">byte</td><td>Byte</td><td style="text-align:center">8</td><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">是</td><td style="text-align:center">[-2^7, 2^7 - 1]</td></tr><tr><td style="text-align:center">short</td><td>Short</td><td style="text-align:center">16</td><td style="text-align:center">2</td><td style="text-align:center">0</td><td style="text-align:center">是</td><td style="text-align:center">[-2^15, 2^15 - 1]</td></tr><tr><td style="text-align:center">int</td><td>Integer</td><td style="text-align:center">32</td><td style="text-align:center">4</td><td style="text-align:center">0</td><td style="text-align:center">是</td><td style="text-align:center">[-2^31, 2^31 - 1]</td></tr><tr><td style="text-align:center">long</td><td>Long</td><td style="text-align:center">64</td><td style="text-align:center">8</td><td style="text-align:center">0L</td><td style="text-align:center">是</td><td style="text-align:center">[-2^ 63, 2^63 - 1]</td></tr><tr><td style="text-align:center">float</td><td>Float</td><td style="text-align:center">32</td><td style="text-align:center">4</td><td style="text-align:center">0f</td><td style="text-align:center">否</td><td style="text-align:center">1.4E-45 ~ 3.4028235E38</td></tr><tr><td style="text-align:center">double</td><td>Double</td><td style="text-align:center">64</td><td style="text-align:center">8</td><td style="text-align:center">0d</td><td style="text-align:center">否</td><td style="text-align:center">4.9E-324 ~ 1.7976931348623157E308</td></tr><tr><td style="text-align:center">char</td><td>Character</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">‘u0000’</td><td style="text-align:center">是</td><td style="text-align:center">0 ~ 65535（2^16 - 1）</td></tr><tr><td style="text-align:center">boolean</td><td>Boolean</td><td style="text-align:center">1</td><td style="text-align:center">未明确定义</td><td style="text-align:center">false</td><td style="text-align:center">是</td><td style="text-align:center">true、false</td></tr></tbody></table><p>Java中，局部变量会被存入Java虚拟机栈中的局部变量表中，未被static修饰的基本数据则被存入Java虚拟机的堆中。而对于包装类，其本质是一个对象，而显而易见，基本上所有对象都被存在堆中。</p><div class="note note-info">            <p><strong>为什么说是几乎所有对象实例都存在于堆中呢？</strong> 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存 <sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[基础常用面试题总结(上)](https://javaguide.cn/java/basis/java-basic-questions-01.htmlJava)">[1]</span></a></sup></p>          </div><h2 id="基础数据包装类的默认缓存">基础数据包装类的默认缓存</h2><p>Java为大部分基础数据的包装类都添加了默认缓存，对于整型系列，都有[-128, 127]的缓存。对于Character则是[0,127]，而对于Boolean则是(True, False)。</p><p>默认缓存的意义在于将一些经常使用的对象优先进行缓存，以便在实际操作时减少由于频繁创建对象带来的性能损耗。</p><p><strong>缓存的实现，从底层代码来看是一目了然的</strong>。这里给一个Integer的例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">valueOf</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>        <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(i);<br>&#125;<br><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerCache</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> -<span class="hljs-number">128</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> high;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-comment">// high value may be configured by property</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-number">127</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">integerCacheHighPropValue</span> <span class="hljs-operator">=</span><br>            sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>        <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> parseInt(integerCacheHighPropValue);<br>                i = Math.max(i, <span class="hljs-number">127</span>);<br>                <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>            &#125;<br>        &#125;<br>        high = h;<br><br>        cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[(high - low) + <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>            cache[k] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>(j++);<br><br>        <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>        <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">IntegerCache</span><span class="hljs-params">()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到，<strong><code>...Cache</code>是一个静态类</strong>，内部信息在类加载的时候便会被加载到内存中去（<strong>放进常量池</strong>）。<code>...Cache</code>这个静态类中维护了一个类型为<code>...</code>的数组，并在类加载时便初始化。valueOf()方法通常在装箱的时候调用，因此可以知道，装箱时并不是直接创建一个存储了基本类型的对象，而是先对基本类型进行一个范围判断知乎决定是否创建一个新的对象还是从缓存中获取对象。其他的包装类缓存也是大同小异，不过可以从中看出来，缓存的上限是可以通过JVM参数自定义的：<code>-XX:AutoBoxCacheMax</code>。</p><p>对于浮点数系列则没有设置缓存，个人觉得有如下几个原因：</p><ol><li>浮点是连续的。相较于整型，浮点很难在实际操作中对某一些数进行预缓存，并且经常使用它们。既然无法确保这一点，便无法提升性能。</li><li>浮点本身便有精度问题。</li></ol><h2 id="装箱与拆箱">装箱与拆箱</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Integer</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 装箱</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> a; <span class="hljs-comment">// 拆箱</span><br></code></pre></td></tr></table></figure><p><strong>装箱：</strong> 调用包装类的valueOf()方法 （<code>Integer a = Integer.valueOf(10);</code>），因此在装箱时会判断对应值是否在缓存范围内，来决定是否直接返回缓存内容。</p><p><strong>拆箱：</strong> 调用xxxValue()方法 (<code>int b = a.intValue();</code>)。</p><h2 id="浮点数精度问题">浮点数精度问题</h2><p>其实很好理解，计算机来理解一个数，总是会有一个用于存储数据的字节量，而这个字节量一定是有限的，所以只能够存储一定位数的数据。作为浮点数（小数），我们都知道，我们无法确保其一定会是有限位数的小数，比如说无限循环小数，无理数等等。这些书无法用限定的字节量来精确表达，只能够到让它们到了一定小数点后位数之后将其截断，这也就是造成了浮点数的精度问题的其中之一。</p><p>我个人认为这么回答也没有问题，但是浮点数精度问题也是由于用于表示浮点数的二进制标准带来的问题。对于float来说，字节位数为32，细节分下来：第一位为符号位，2-9是指数位，10-32是尾数位。(double则是1为符号位，2-12是指数位，13-64是尾数位)。理论上而言，足够长的位数能够将浮点数的精度误差近似为0，但是终究会有表示能力的问题，这会让一些十进制的小数在表示二进制时是无限循环小数。</p><h3 id="如何解决精度问题">如何解决精度问题</h3><p><strong>考虑浮点数本身：</strong> 可以使用<code>BigDecimal</code>类来解决精度问题</p><p><strong>考虑浮点数之间的大小关系问题</strong> ： 可以为浮点数之间设一个误差空间来消除精度带来的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">float</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">2.0f</span> - <span class="hljs-number">1.9f</span>;<br><span class="hljs-type">float</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.8f</span> - <span class="hljs-number">1.7f</span>;<br>System.out.println(a == b); <span class="hljs-comment">// false</span><br>System.out.println(Math.abs(a  - b) &lt; <span class="hljs-number">0.00001f</span>); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><h1>引用</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://javaguide.cn/java/basis/java-basic-questions-01.htmlJava">基础常用面试题总结(上)</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>数据类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习 - 面向对象</title>
    <link href="/2024/11/26/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2024/11/26/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1>面向对象</h1><h2 id="何为面向对象？"><strong>何为面向对象？</strong></h2><p>面向对象是一种软件开发方法，一种编程范式<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="[百度百科：面向对象](https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089)">[1]</span></a></sup>。面向对象编程时一种以“<strong>对象</strong>”为核心的编程范式，而Java是一门典型的面向对象编程语言。通过<strong>类和对象</strong>的概念，将现实世界的实体机器行为映射到程序中。</p><ul><li><p><strong>类 (Class)：</strong> 类是对象的模板或蓝图，定义了对象的属性和方法。</p></li><li><p><strong>对象 (Object)：</strong> 对象是类的实例，具体表现为程序中具有独立状态和行为的实体。</p></li><li><p><strong>方法 (Method)：</strong> 定义对象的行为（功能）。</p></li><li><p><strong>属性 (Attribute)：</strong> 描述对象的特征（数据）。<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="来自于GPT老师">[2]</span></a></sup></p></li></ul><p>这样解释程序结构与事物之间的联系是十分符合人的逻辑的，因此人们可以通过这个形式，给予程序结构各种不一样的设计。</p><h2 id="与面向过程的区别">与面向过程的区别</h2><p>面向过程将一个任务中所需要用到的方法拆开并进行使用。而面向对象则是创建一个个对象，并基于对象与对象之间的关系和他们内部的一些行为和方法来完成任务。</p><p>可以看出来，面向过程是针对任务的，相较面向对象会更加一目了然，并且少了很多步骤，因此面向过程的执行效率比面向对象要快。但是代码设计更加单一，难以管理和进行扩展重构，缺乏结构性和灵活性。</p><h2 id="面向对象的三大核心特征：封装，继承，多态"><strong>面向对象的三大核心特征：封装，继承，多态</strong></h2><h3 id="封装："><strong>封装：</strong></h3><p>将数据与方法集合（封装）到一起，使其形成一个独立的实体。数据在实体的内部，可以隐藏内部细节，只对外部开放一些接口来与外部产生联系。</p><p><strong>优点：</strong></p><ul><li><strong>减少耦合</strong>：确保了实体为独立的，因此一个实体的修改并不会对其他实体本身造成影响。</li><li><strong>方便性能检测：</strong> 因为试图独立且扮演着各自的角色与行为，因此在检测影响性能的因素时能够更加清晰地确定哪里出了问题。</li><li><strong>降低构建大型系统的风险：</strong> 系统的崩溃也许并不是因为这个独立的实体造成的。</li><li><strong>提高安全性：</strong> 有效隐藏了实体的内部信息，降低受到更改和攻击的风险。</li><li>符合直觉</li></ul><h3 id="继承："><strong>继承：</strong></h3><p>实现了<strong>A is a B</strong>这样的关系。指的是<strong>一个类（子类）可以从另一个类（父类）中获取属性和方法</strong>，从而实现代码复用和扩展。</p><ol><li><strong>父类（超类 / 基类）：</strong> 提供属性和方法的类。</li><li><strong>子类（派生类）：</strong> 继承父类的类，可以直接使用父类的属性和方法，也可以添加自己的功能。</li></ol><p>比如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mi>h</mi><mi>a</mi><mi>p</mi><mi>e</mi><mo>→</mo><mi>R</mi><mi>e</mi><mi>c</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>g</mi><mi>l</mi><mi>e</mi><mo>→</mo><mi>S</mi><mi>q</mi><mi>u</mi><mi>a</mi><mi>r</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">Shape \rightarrow Rectangle \rightarrow Square</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal">ha</span><span class="mord mathnormal">p</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">ec</span><span class="mord mathnormal">t</span><span class="mord mathnormal">an</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">Sq</span><span class="mord mathnormal">u</span><span class="mord mathnormal">a</span><span class="mord mathnormal">re</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mi>n</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mo>→</mo><mi>R</mi><mi>a</mi><mi>b</mi><mi>b</mi><mi>i</mi><mi>t</mi></mrow><annotation encoding="application/x-tex">Animal \rightarrow Rabbit</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal">nima</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mord mathnormal">abbi</span><span class="mord mathnormal">t</span></span></span></span>， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mi>e</mi><mi>h</mi><mi>i</mi><mi>c</mi><mi>l</mi><mi>e</mi><mo>→</mo><mi>T</mi><mi>r</mi><mi>a</mi><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">Vehicle \rightarrow Train</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal">e</span><span class="mord mathnormal">hi</span><span class="mord mathnormal">c</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">ain</span></span></span></span>​等等。</p><p>继承应该遵循里氏替换原则，子类对象必须能够替换掉所有父类对象。<sup id="fnref:3" class="footnote-ref"><a href="#fn:3" rel="footnote"><span class="hint--top hint--rounded" aria-label="[[Java 全栈知识体系: 面向对象](https://pdai.tech/md/java/basic/java-basic-oop.html)]">[3]</span></a></sup></p><p><strong>优点：</strong></p><ul><li><p><strong>代码复用：</strong> 子类可以直接复用父类的代码，无需重复编写。</p></li><li><p><strong>易于扩展：</strong> 新的功能可以通过扩展现有类实现。</p></li><li><p><strong>逻辑清晰：</strong> 类的层次关系体现了现实世界中“是某种类型”的逻辑。</p></li></ul><p><strong>局限性：</strong></p><ul><li><p><strong>单继承限制：</strong> Java 不支持类的多继承（但可以通过接口实现类似功能）。</p></li><li><p><strong>过度继承问题：</strong> 如果层次过深，子类和父类之间的关系复杂，会导致代码维护困难。</p></li><li><p><strong>强耦合：</strong> 子类与父类高度耦合，父类的修改可能影响所有子类。</p></li></ul><h3 id="多态："><strong>多态：</strong></h3><p><strong>指同一个方法或操作在不同对象中表现出不同的行为</strong><sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="来自于GPT老师">[2]</span></a></sup>。多态主要有两种形式：</p><ol><li><p><strong>编译时多态（静态多态）：</strong> 方法重载（Method Overloading），在同一个类中定义多个拥有相同名称但参数类型或数量不同的方法。</p><ul><li>在<strong>编译器</strong>便决定</li><li><strong>不涉及继承或类层次结构</strong></li></ul></li><li><p><strong>运行时多态（动态多态）：</strong> 方法重写（Method Overriding），在不同类中，<strong>根据实际引用的对象类型调用方法（父类引用指向子类对象）</strong>。</p><ul><li>在<strong>运行期</strong>确定</li><li><strong>需要继承或实现接口</strong></li><li>父类引用可以指向子类对象</li></ul></li></ol><p><strong>优点：</strong></p><ul><li><p><strong>提高代码复用性：</strong> 子类可以直接使用父类的方法或重写其行为，减少代码重复。</p></li><li><p><strong>增强代码灵活性：</strong> 父类引用可以指向不同的子类对象，能够适应需求的变化。</p></li><li><p><strong>支持接口和抽象类的实现：</strong> 多态性使得面向接口编程更加简单。</p></li></ul><h1>问题</h1><ol><li><strong>什么是类？类在 Java 中有什么作用？</strong><ul><li>类在Java中是最基础的组件。类可以将一系列属性和方法综合起来，用于表示某一个东西。一个类可以被理解为一个对象的抽象，在创建对象时，需要使用类来创建实例。</li></ul></li><li><strong>解释 Java 中对象的创建过程，包括内存分配情况。</strong><ul><li>在Java中，<strong>创建对象前需要先用类加载器加载对象对应的类</strong>。流程如下：<ul><li>JVM会在首次使用一个类时加载它，JVM会加载类的字节码(.class)文件到内存中。</li><li>从磁盘或者网络等位置读取类的字节码文件，并将其转换为 JVM 内部可以处理的二进制数据结构，存放在方法区（在 Java 8 及以后，方法区的实现是元空间，位于本地内存）。</li><li>检查字节码文件的格式是否符合 Java 虚拟机规范，确保类文件的正确性，例如检查字节码是否被篡改等。</li><li>为类的静态变量分配内存并设置默认初始值。</li><li>将类、接口、字段和方法的符号引用转换为直接引用。简单来说，就是确定类中引用的其他类、方法等的实际内存地址。</li><li>执行类的初始化代码，主要是执行静态初始化块和对静态变量进行显式赋值。这个阶段是严格按照类中定义的顺序执行的。</li></ul></li><li><strong>创建对象：</strong><ul><li><strong>默认初始化</strong>：分配完内存后，JVM 会对对象的成员变量进行默认初始化。例如，对于基本数据类型，<code>int</code>类型会被初始化为 0，<code>boolean</code>类型会被初始化为<code>false</code>，引用类型会被初始化为<code>null</code>。</li><li><strong>显式初始化</strong>：接着会按照类中定义的变量初始化顺序，对成员变量进行显式初始化。例如，如果在<code>Person</code>类中有<code>private int age = 20;</code>，那么<code>age</code>会被初始化为 20。</li><li><strong>构造方法调用</strong>：最后会调用对象的构造方法。构造方法可以对对象进行更复杂的初始化操作，例如，在<code>Person</code>类的构造方法中可以初始化其他成员变量或者执行一些其他的逻辑操作。</li></ul></li></ul></li><li><strong>简述 Java 中构造函数的特点和用途，它与普通方法有何区别？</strong><ul><li>构造函数在创建对象实例时调用，通常用于初始化对象的属性，或者执行一些创建对象时所需的流程。</li><li>与普通方法的区别：<ol><li>代码中不需要定义返回类型，且没有返回值</li><li>无法被重写，但可以被重构</li><li>构造函数名必须与类名完全一致</li><li>生成类对象时，自动被调用</li></ol></li></ul></li><li><strong>继承在 Java 中有什么意义？请举例说明如何实现类的继承以及继承带来的好处和潜在风险。</strong><ul><li>继承可以让一个类（子类）从另一个类（父类）中获取属性和方法，并可以灵活地重写与进行扩展，符合面向对象的编程思想。</li><li>好处：代码复用，符合直觉，可灵活拓展</li><li>潜在风险：与父类或子类高度耦合；Java仅支持单继承；继承程度过深也许会导致代码维护难度大幅度提高。</li></ul></li><li><strong>什么是多态？在 Java 中如何通过方法重写和方法重载来体现多态性？</strong><ul><li>多态即方法可以被重载或重写，以让同一个方法在不同对象中具有不同的行为。重载即同名方法在使用不同类型和长度的参数时有着不同的行为。而重写则是在类中覆盖父类或接口方法来让类的行为变得不同。</li></ul></li><li><strong>接口在 Java 中的作用是什么？它与抽象类有哪些异同点？</strong><ul><li>接口在Java中可以让类具备某种功能或特性但并非继承关系。与抽象类不同的是接口可以多继承，但抽象类不能。因为抽象类主张的还是类与类之间的关系，强调代码复用。</li></ul></li><li><strong>如何在 Java 中实现封装？封装的好处有哪些？</strong><ul><li>Java中，可以将一个类考虑成一个封装的实现，因为封装的本意就是将多个数据和方法集合到一起，并且规定他们对外的可见度。</li><li>封装的好处：提高安全性；方便管理；减少耦合</li></ul></li><li><strong>谈谈你对 Java 中访问修饰符（public、private、protected、default）的理解，它们分别在什么场景下使用？</strong><ul><li><strong>public</strong>: 用public修饰的属性和方法对外是公开的，外部对象可以随时访问这些属性和方法并且进行修改和调用。</li><li><strong>private</strong>：用private修饰的属性和方法不对外公开，是内部私有的，只有对象本身可以对其进行直接访问和修改。</li><li><strong>protected</strong>：用protect修饰的属性和方法只对自己和子对象公开，其余对象无法访问和修改。</li><li><strong>default</strong>：在Java中，没有用任何修饰符修饰的属性或方法便为default。具有default访问权限的内容对同一个保重的其他类和对象是可见的。从Java 8开始，default被用来修饰接口中的方法，旨在为接口中的方法定义默认行为，这样即可在不修改实现类的情况下直接添加新功能。</li></ul></li><li><strong>静态成员（静态变量和静态方法）在 Java 中有什么特性？它们与实例成员有何不同？</strong><ul><li>静态成员与实例成员的不同就在于，静态成员属于类，而实例成员属于实例对象。静态成员在进行类加载的时候便会为其分配内存，而实例成员则需要在创建一个对象时才会对齐进行初始化和分配内存。</li></ul></li></ol><h1>引用</h1><h1></h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://baike.baidu.com/item/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/2262089">百度百科：面向对象</a><a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span>来自于GPT老师<a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:3" class="footnote-text"><span>[<a href="https://pdai.tech/md/java/basic/java-basic-oop.html">Java 全栈知识体系: 面向对象</a>]<a href="#fnref:3" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>面向对象</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习 - JVM, JDK, JRE</title>
    <link href="/2024/11/24/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20JVM,%20JDK,%20JRE/"/>
    <url>/2024/11/24/Java%E5%AD%A6%E4%B9%A0/Java%E5%AD%A6%E4%B9%A0%20-%20JVM,%20JDK,%20JRE/</url>
    
    <content type="html"><![CDATA[<h1>Java SE vs Java EE</h1><p>简单来说，对比于Java，Java SE是Java的基础版本，包括了支持Java变成语言的基本功能和标准库，比如集合框架，IO，网络，并发等等。Java SE 适合用于小型或单机的应用程序，亦或者是控制台应用程序和工具（自动化脚本等）。而Java EE则是面向于开发复杂的企业级分布式应用，提供了面向企业级开发的扩展框架和API，比如Web服务、EJB、JPA等。Java EE适合用于企业级分布式应用，适用于具有多层架构系统和高并发，高可用性需求的大型应用程序。</p><p>由此，显然可以看出，Java EE对比Java SE是一个复杂得多的Java开发框架，因此，Java SE的应用场景和部署，配置难度对比起Java EE都简单许多。</p><h1>JVM vs JDK vs JRE</h1><p>从包含的角度来看，可以看成</p><p class="katex-block "><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>J</mi><mi>V</mi><mi>M</mi><mo>⊂</mo><mi>J</mi><mi>R</mi><mi>E</mi><mo>⊂</mo><mi>J</mi><mi>D</mi><mi>K</mi></mrow><annotation encoding="application/x-tex">JVM \subset JRE \sub JDK</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.05764em;">RE</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">⊂</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.07153em;">DK</span></span></span></span></span></p><p><strong>JVM (Java Virtual Machine)</strong>， 顾名思义，就是Java虚拟机。JVM是实现让Java程序真正做到&quot;Write Once, Run Everywhere&quot;的功臣，其可以针对不同系统，使用相同的字节码和不同的实现方法，以得到相同的结果。</p><p><strong>JRE (Java RunTime Environment)</strong>， 顾名思义，也就是Java运行环境。其中显然包含了虚拟机，也包含了一系列基本的内置类库，用与基本运行Java程序所需的环境和类库。</p><p><strong>JDK (Java Development Kit)</strong>，顾名思义，也就是Java开发工具包，其中包含了JRE和JVM，并能够创建和编译Java程序(javac)。JDK拥有更多额外的工具，比如javadoc（文档生成器）、jdb（调试器）、jconsole（监控工具）、javap（反编译工具）等<sup id="fnref:2" class="footnote-ref"><a href="#fn:2" rel="footnote"><span class="hint--top hint--rounded" aria-label="[Java Guide: 基础常见面试题总结（上）](https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm-vs-jdk-vs-jre)">[2]</span></a></sup>。</p><h1>优化一下Java运行速度吧！</h1><p>Java程序的运行逻辑基本上可以理解为：</p><pre><code class=" mermaid">graph LRc1[编写.java文件] --javac编译--&gt; c2[生成.class 字节码文件]c2 --JVM解释器&amp;JIT--&gt; c3[机器码]c3 --&gt; 运行程序</code></pre><p>在将.class文件转化为机器码的过程中，JVM类加载器首先会加载.class文件,然后通过解释器逐行解释执行。可以看出，这样子会比较慢。由于有些代码块会经常被调用，因此，不难想到可以将这些经常被用到的代码块的机器码保存下来，以节省大量的时间，这看起来就像是一种缓存的机制。</p><p>综上，Java引进了名为**JIT (Just In Time Compilation)**的编译器，使其在程序运行时进行动态的编译。其核心逻辑是，对于热点代码块，JIT会在完成第一次编译后将对应的机器码保存下来，以供下次直接使用。这时候我想到了一个问题：<strong>对于一个庞大的系统来说，JIT所带来的缓存量也会很大，也许会对内存带来很大的压力。我们应该如何处理这个问题？</strong></p><h2 id="JVM如何管理JIT缓存的内存-sup-id-fnref-1-class-footnote-ref-a-href-fn-1-rel-footnote-span-class-hint-top-hint-rounded-aria-label-来自于GPT老师-1-span-a-sup">JVM如何管理JIT缓存的内存<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="来自于GPT老师">[1]</span></a></sup></h2><p>JVM 使用以下机制来管理 JIT 编译生成的本地代码及其缓存：</p><ol><li><strong>代码缓存区（Code Cache）：</strong><ul><li>JVM 在内存中分配一个固定大小的区域，用于存储 JIT 编译后的本地机器码。</li><li>代码缓存有容量限制，当缓存满时，JVM 会自动清理较老或较少使用的编译代码，以腾出空间给新的热点代码。</li></ul></li><li><strong>分层编译（Tiered Compilation）：</strong><ul><li>JVM 会分阶段优化代码，减少不必要的内存占用。<ul><li>初始阶段：使用 C1 编译器快速生成基本的本地代码，占用内存少但优化程度较低。</li><li>热点阶段：使用 C2 编译器对高频代码进行深度优化，占用更多内存，但执行效率更高。</li></ul></li><li>如果代码热点不再频繁使用，JVM 可能会将其标记为可清理对象。</li></ul></li><li><strong>垃圾回收（GC）与代码缓存清理：</strong><ul><li>JVM 的垃圾回收机制不仅负责清理堆内存，还可以清理代码缓存中的无用代码。</li><li>无效或不再使用的 JIT 编译代码会被标记并清理，以释放内存。</li></ul></li></ol><p>对于代码缓存，JVM提供了一些参数用来调整缓存区域的大小，或者是将代码块识别为热点代码所需的阈值:</p><ul><li><code>-XX:InitialCodeCacheSize</code>: 代码缓存的初始大小</li><li><code>-XX:ReservedCodeCacheSize</code>: 代码缓存的最大大小</li><li><code>-XX:CompileThreshold</code>: 将代码识别为热点代码所需的调用次数阈值</li></ul><h2 id="Java包装类的缓存">Java包装类的缓存</h2><p><strong>包装类</strong>是对Java中基本类型的封装。一般来说，包装类的创建<code>.valueOf(...)</code>会占用内存，而对于一些常用的、小范围的数值（例如 0 到 127 的 <code>Integer</code>），频繁创建和销毁对象会导致较大的内存浪费。因此，在JDK5中引入了一个缓存机制，其会在类初始化时，提前创建好会被频繁使用的包装类对象。这种机制常见于 <code>Integer</code>、<code>Byte</code>、<code>Short</code>、<code>Long</code> 和 <code>Character</code> 等包装类，目的是为了优化内存的使用并提高性能。</p><p><strong>注意：在构造函数中，不会使用缓存机制，比如：</strong><code>Integer a = new Integer(100);</code></p><p><strong>自动装箱的过程会使用缓存，因为其底层代码是调用了封装类的</strong><code>valueOf()</code><strong>这个方法</strong>。</p><h1>参考资料</h1><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>来自于GPT老师<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li><li><span id="fn:2" class="footnote-text"><span><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#jvm-vs-jdk-vs-jre">Java Guide: 基础常见面试题总结（上）</a><a href="#fnref:2" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JVM</tag>
      
      <tag>JDK</tag>
      
      <tag>JRE</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
